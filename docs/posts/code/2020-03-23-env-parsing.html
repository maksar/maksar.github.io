<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Shestakov Alex Blog - Parsing environment variables with reverse tests</title>
  <link rel="stylesheet" href="../../css/default.css" />

  <script type="text/javascript" src="../../vendor/jquery/jquery-3.6.0.min.js"></script>
  <script type="text/javascript" src="../../vendor/fresco/js/fresco.min.js"></script>
  <link rel="stylesheet" type="text/css" href="../../vendor/fresco/css/fresco.css" />

  <link rel="stylesheet" href="../../vendor/highlight/styles/atom-one-dark.min.css">
  <script src="../../vendor/highlight/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body>
  <header>
    <div class="logo">
      <a href="../../">Shestakov Alex</a>
    </div>
    <nav>
      &amp;<a href="../../languages/english.html">english</a> &amp;<a href="../../languages/russian.html">russian</a>
      @<a href="../../categories/WAT.html">WAT</a> @<a href="../../categories/code.html">code</a> @<a href="../../categories/projects.html">projects</a>
      <a href="../../about.html">About</a>
    </nav>
  </header>

  <main role="main">
    <h1>Parsing environment variables with reverse tests</h1>
    <article>
  <span class="header">
    March 23, 2020 &amp;<a href="../../languages/russian.html">russian</a> @<a href="../../categories/code.html">code</a> #<a href="../../tags/haskell.html">haskell</a> #<a href="../../tags/lens.html">lens</a> #<a href="../../tags/polysemy.html">polysemy</a> #<a href="../../tags/QuickCheck.html">QuickCheck</a>
  </span>
  <section>
    <p>Тема сегодняшней статьи – чтение конфигурационных значений из переменных окружения и связанные с этим процессом трудности. В небольших системах, где нет необходимости в полноценном конфигурационном файле, принято брать настройки из переменных окружения, это один из ключевых моментов <a href="https://12factor.net/config">12 factor app</a> манифеста. Это надежный и относительно безопасный способ конфигурации, он отлично поддерживается всеми операционными системами, облачными платформами и средствами контейнеризации.</p>
<!--more-->
<p><img src="../../previews/env-parsing/logo.jpg" class="center" /></p>
<p>“Так а что сложного-то?” спросите вы, “в любом языке программирования есть для этого встроенные средства, сдобренные ни одним десятком библиотек, упрощающих этот процесс. Действительно, проблем с тем, чтобы прочитать значение переменной окружения нет. Но если подходить к задаче не системно, запрашивая значения переменных окружения там и тут в коде, трудности все-же начнутся. Такую программу будет сложно сопровождать, так как существует множество мест в коде системы, где идет обращение к одной и той же переменной окружения. Но самое важное – такую систему будет сложно тестировать – необходимо использовать дополнительные ухищрения для подмены значений переменных окружения в тестовом режиме работы. Трудностей, со временем, будет становиться все больше, так как с добавлением нового функционала вырастет и количество настроек.</p>
<p>Способ преодоления таких трудностей эволюционно-естественен – необходимо сконцентрировать работу с конфигурацией в одном месте, сделать процесс добавления новой настройки понятным, упростить доступ к настройкам в коде бизнес-логики.</p>
<h2 id="постановка-задачи">Постановка задачи</h2>
<p>В <code>Haskell</code>, несмотря на всю его “строгость” и приверженность к математически чистым функциям, тоже можно обращаться к переменным окружения откуда угодно, но “тут так не принято”… Язык подталкивает программиста отказаться от идеи так делать, заставляя явно отказываться от “чистоты” функций и терять все связанные с этим свойством преимущества. В мире строго-типизированных языков “удобно” не читать “настройки” посреди кода с логикой, а читать их в начале исполнения программы, преобразовать во внутреннюю структуру данных (с адекватными типами вместо строк) и использовать явно передавая такую структуру или ее части в остальные “вычисления” оставляя их свободными от side-effect-ов.</p>
<p>Довольно философствований, show me the code, как говорится.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _ldapHost               ::</span> <span class="dt">Text</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _ldapPort               ::</span> <span class="dt">PortNumber</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _port                   ::</span> <span class="dt">Int</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _verifyToken            ::</span> <span class="dt">Text</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _pageToken              ::</span> <span class="dt">Text</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _user                   ::</span> <span class="dt">Text</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _password               ::</span> <span class="dt">Text</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _activeUsersContainer   ::</span> <span class="dt">Dn</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _projectGroupsContainer ::</span> <span class="dt">Dn</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _projectGroupsOrgunits  ::</span> <span class="dt">NonEmpty</span> <span class="dt">Text</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Default</span>)</span></code></pre></div>
<p><code>Config</code> – та самая структура данных с настройками, необходимыми для работы <a href="../../posts/projects/2020-02-07-ldap-bot.html">Group Manager</a> бота. В начале работы системы, эта структура заполняется значениями из переменных окружения.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readConfig ::</span> (<span class="dt">Member</span> <span class="dt">Environment</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">Text</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">Config</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>readConfig <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Config</span> <span class="op">&lt;$&gt;</span> lookupText <span class="st">&quot;LDABOT_LDAP_HOST&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupNumber <span class="st">&quot;LDABOT_LDAP_PORT&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupNumber <span class="st">&quot;LDABOT_PORT&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupText <span class="st">&quot;LDABOT_VERIFY_TOKEN&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupText <span class="st">&quot;LDABOT_PAGE_TOKEN&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupText <span class="st">&quot;LDABOT_USERNAME&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> lookupText <span class="st">&quot;LDABOT_PASSWORD&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> (<span class="dt">Dn</span> <span class="op">&lt;$&gt;</span> lookupText <span class="st">&quot;LDABOT_USERS_CONTAINER&quot;</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> (<span class="dt">Dn</span> <span class="op">&lt;$&gt;</span> lookupText <span class="st">&quot;LDABOT_GROUPS_CONTAINER&quot;</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;*&gt;</span> (fromList <span class="op">.</span> splitOn <span class="st">&quot;,&quot;</span> <span class="op">&lt;$&gt;</span> lookupText <span class="st">&quot;LDABOT_GROUPS_ORGUNITS&quot;</span>)</span></code></pre></div>
<p>Как ни странно, функция <code>readConfig</code> является “чистой”, хотя вроде бы и обращается к внешнему миру (то есть имеет side-effect-ы). Почему это так и как работает – я расскажу в следующей статье про “алгебраические эффекты”. А пока, еще немного деталей реализации:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupText ::</span> (<span class="dt">Member</span> <span class="dt">Environment</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">Text</span>) r) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">Text</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lookupText name <span class="ot">=</span> lookupEnv name <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> throw <span class="op">$</span> <span class="fu">unwords</span> [<span class="st">&quot;Please set&quot;</span>, name, <span class="st">&quot;environment variable.&quot;</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> string <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">pack</span> string</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupNumber ::</span> (<span class="dt">Read</span> a, <span class="dt">Member</span> <span class="dt">Environment</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">Text</span>) r) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>lookupNumber name <span class="ot">=</span> <span class="fu">read</span> <span class="op">.</span> unpack <span class="op">&lt;$&gt;</span> lookupText name</span></code></pre></div>
<p>Функция <code>lookupText</code> обращается к операционной системе через <code>lookupEnv name</code> и анализирует результат. Если значения не оказалось – генерируется ошибка, в противном случае – функция возвращает значение переменной окружения. <code>lookupNumber</code> является надстройкой над <code>lookupText</code>, которая после успешного получения значения конвертирует его в число. Интересным моментом тут является оператор <code>&lt;$&gt;</code> (так же известный как <code>fmap</code> в <code>Haskell</code> или <code>Optional.map</code> в <code>Java</code>). Его использование позволяет “не засорять” код обработкой граничных случаев вида “если <code>lookupText</code> вернул <code>null</code>, то тоже вернуть <code>null</code>; в противном случае – преобразовать в число и вернуть”. Если вы вспомнили про elvis-оператор, то знайте, он является лишь частным случаем <code>fmap</code> для <code>null</code>-ов ;)</p>
<p><code>&lt;$&gt;</code> несколько раз применяется еще и внутри <code>readConfig</code> для тех же целей – преобразовывать прочитанное из <code>LDABOT_USERS_CONTAINER</code> в <code>Dn</code> (термин из мира <code>LDAP</code>, означает <code>distinguished name</code>) есть смысл только если там что-то было. Самое первое использование <code>&lt;$&gt;</code> немного интереснее. Помните рассказ про <code>&lt;$&gt;</code> из <a href="../../posts/code/2020-02-27-aeson-parsing.html">первой статьи</a> про парсинг <code>json</code>-а? Речь шла о том, чтобы “адаптировать” конструктор структуры данных <code>Message</code> (который принимает строки) к “парсеру строк”. Если посмотреть на такую адаптацию с другой стороны – операция <code>&lt;$&gt;</code> превращала “парсер строк” в “парсер <code>Message</code>-ей” постулируя “когда (и если) оригинальный парсер строк что-нибудь вернет, примени к этому конструктор <code>Message</code>”.</p>
<p>С <code>Config</code>-ом ситуация та же, оператор <code>&lt;$&gt;</code> постулирует “когда (и если) <strong>все</strong> операнды для вызова функции <code>Config</code> будут готовы – вызывай”. Если ранее мы конструировали <code>Message</code> “в контексте” парсера, который может ничего “не напарсить”, то сейчас мы конструируем <code>Config</code> “в контексте” вычисления, которое может вернуть ошибку. <code>fmap</code> – он как обычный <code>map</code>, только не для списков, а для любых “контейнеров” или “вычислений” (деревья, Optional, парсер, генератор). Подготовка операндов происходит при помощи <code>&lt;*&gt;</code>. Его отличие от <code>&lt;$&gt;</code> в том, что теперь с обоих сторон “вычисления, которые могут вернуть ошибку”. Механика сложная, зато код элегантный, без постоянных проверок (привет программистам на <code>golang</code>) и early return-ов.</p>
<h2 id="тестирование">Тестирование</h2>
<p>С проблематикой вроде разобрались, пора начинать извлекать пользу. из “централизации” работы с настройками а так же от использования “чистых” функций (не зря же прилагались усилия). С точки зрения кода, читающего значения переменных – совершенно не важно откуда именно происходит чтение – из реальных переменных окружения или из заранее подготовленного ассоциативного массива, главное, чтобы <code>lookupEnv</code> возвращала <code>Maybe Text</code>. Определив “тестовое окружение” как простой писок ключ-значение <code>type EnvironmentMock = [(Text, Text)]</code>, можно заставить <code>readConfig</code> читать данные из заранее подготовленного места.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withMockedEnvironment ::</span> <span class="dt">EnvironmentMock</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> '[<span class="dt">Environment</span>, <span class="dt">Error</span> <span class="dt">Text</span>] a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>withMockedEnvironment mockedEnv <span class="ot">=</span> run <span class="op">.</span> runError <span class="op">.</span> fakeEnvironment mockedEnv</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fakeEnvironment ::</span> <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">Text</span>) r <span class="ot">=&gt;</span> <span class="dt">EnvironmentMock</span> <span class="ot">-&gt;</span> <span class="dt">InterpreterFor</span> <span class="dt">Environment</span> r</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>fakeEnvironment mockedEnv <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LookupEnv</span> name <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> unpack <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> name mockedEnv</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>withMockedEnvironment</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  [ (<span class="st">&quot;LDABOT_LDAP_HOST&quot;</span>, <span class="st">&quot;host&quot;</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_LDAP_PORT&quot;</span>, <span class="st">&quot;123&quot;</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PORT&quot;</span>, <span class="st">&quot;234&quot;</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_VERIFY_TOKEN&quot;</span>, <span class="st">&quot;vtoken&quot;</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PAGE_TOKEN&quot;</span>, <span class="st">&quot;ptoken&quot;</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_USERNAME&quot;</span>, <span class="st">&quot;user&quot;</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PASSWORD&quot;</span>, <span class="st">&quot;pass&quot;</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_USERS_CONTAINER&quot;</span>, <span class="st">&quot;ucont&quot;</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_GROUPS_CONTAINER&quot;</span>, <span class="st">&quot;gcont&quot;</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_GROUPS_ORGUNITS&quot;</span>, <span class="st">&quot;ou1,ou2&quot;</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  ] readConfig <span class="ot">`shouldBe`</span> <span class="dt">Right</span> <span class="dt">Config</span> {</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    _ldapHost <span class="ot">=</span> <span class="st">&quot;host&quot;</span>,</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    _ldapPort <span class="ot">=</span> <span class="dv">123</span>,</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    _port <span class="ot">=</span> <span class="dv">234</span>,</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    _verifyToken <span class="ot">=</span> <span class="st">&quot;vtoken&quot;</span>,</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    _pageToken <span class="ot">=</span> <span class="st">&quot;ptoken&quot;</span>,</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    _user <span class="ot">=</span> <span class="st">&quot;user&quot;</span>,</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    _password <span class="ot">=</span> <span class="st">&quot;pass&quot;</span>,</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    _activeUsersContainer <span class="ot">=</span> <span class="dt">Dn</span> <span class="st">&quot;ucont&quot;</span>,</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    _projectGroupsContainer <span class="ot">=</span> <span class="dt">Dn</span> <span class="st">&quot;gcont&quot;</span>,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    _projectGroupsOrgunits <span class="ot">=</span> <span class="st">&quot;ou1&quot;</span> <span class="op">:|</span> [<span class="st">&quot;ou2&quot;</span>]</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Как говорит один мой знакомый, “мало вариативности”. Он ярый поклонник разработки через тесты, (привет тебе, В.С.)“. Ну что-ж, постараемся добавить вариативности и уважить скептиков, заявляющих при чтении таких тестов –”а как убедиться в том, что реализация не состоит из хардкода именно этих значений”.</p>
<p>Есть такой прием в тестировании – проверять обратимость (<code>reverse(reverse(list)) === list</code>). Построение конфига из окружения - назовем прямым преобразованием Окружение -&gt; Конфиг. Если бы у нас было обратное преобразование (из Конфига в Окружение, из которого такой Конфиг прочитан), то мы бы могли проверить, что применив сначала прямое преобрзование, а затем обратное – получается исходный Конфиг. Такую пару Окружения и Конфига называют изоморфной, а само преобразование – изоморфизмом. Как обычно бывает в математике – слово сложное, но за ним стоит простая идея ;)</p>
<p>Если сначала конфиг (абсолютно любой) преобразовать в набор пар ключ-значение, а потом из них попытаться “прочитать” конфиг обратно, то в итоге должны ведь получить исходный конфиг.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toEnvironmentMock ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">EnvironmentMock</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>toEnvironmentMock <span class="dt">Config</span> {<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  [ (<span class="st">&quot;LDABOT_LDAP_HOST&quot;</span>, unpack _ldapHost)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_LDAP_PORT&quot;</span>, <span class="fu">show</span> _ldapPort)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PORT&quot;</span>, <span class="fu">show</span> _port)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_VERIFY_TOKEN&quot;</span>, unpack _verifyToken)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PAGE_TOKEN&quot;</span>, unpack _pageToken)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_USERNAME&quot;</span>, unpack _user)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_PASSWORD&quot;</span>, unpack _password)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_USERS_CONTAINER&quot;</span>, fromDn _activeUsersContainer)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_GROUPS_CONTAINER&quot;</span>, fromDn _projectGroupsContainer)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;LDABOT_GROUPS_ORGUNITS&quot;</span>, unpack <span class="op">$</span> intercalate <span class="st">&quot;,&quot;</span> <span class="op">$</span> toList _projectGroupsOrgunits)]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    fromDn (<span class="dt">Dn</span> dn) <span class="ot">=</span> unpack dn</span></code></pre></div>
<p>Имея прямое и обратное преобразование, можно записать:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>it <span class="st">&quot;reads config from complete environment&quot;</span> <span class="op">$</span> forAll <span class="op">$</span> \config <span class="ot">-&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  withMockedEnvironment (toEnvironmentMock config) readConfig <span class="op">===</span> <span class="dt">Right</span> config</span></code></pre></div>
<p>Но это только success случай мы протестировали, пока не ясно как будет себя вести функция чтения конфига, если в переменных окружения будет отсутствовать одно из значений. Но погодите-ка – ведь у нас же есть способ получить окружение в виде списка ключ-значение. Достаточно только удалить из нее одну (случайную) строку и попытаться прочитать конфиг:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>it <span class="st">&quot;fails to read a config from incomplete environment&quot;</span> <span class="op">$</span> forAll <span class="op">$</span> \config <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  shuffled <span class="ot">&lt;-</span> shuffle <span class="op">$</span> toEnvironmentMock config</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ((missingKey, _), incompleteMock) <span class="ot">=</span> (<span class="fu">head</span> shuffled, <span class="fu">tail</span> shuffled)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> withMockedEnvironment incompleteMock readConfig <span class="op">===</span> <span class="dt">Left</span> (<span class="fu">unwords</span> [<span class="st">&quot;Please set&quot;</span>, missingKey, <span class="st">&quot;environment variable.&quot;</span>])</span></code></pre></div>
<p>Ну вот, кажется удалось свести задачу тестирования функции чтения конфигурации к формированию произвольных конфигов. Эта задача для <code>Haskell</code> довольно типична – использовать property-based тестирование на нем очень любят. Так как структура <code>Config</code> состоит из достаточно примитивных типов и оберток над ними, то “произвольность” можно обеспечить с помощью всего нескольких строк.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>makeArbitrary '<span class="dt">'Config</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Config</span> <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> arbitraryConfig</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  shrink <span class="ot">=</span> recursivelyShrink</span></code></pre></div>
<p>Благодаря тому, что <code>Config</code> теперь “реализует” <code>Arbitrary</code>, можно создавать “генератор” конфигов – <code>Gen Config</code> при помощи функции <code>arbitrary</code> из класса.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</span></code></pre></div>
<p>Попробуем в REPL-е сгенерировать что-нибудь случайное:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>sample (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Config</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Config</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  { _ldapHost <span class="ot">=</span> <span class="st">&quot;\nIUZ\DELu\EMUG1\DEL\1002298\11790\DC3s\STX&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  , _ldapPort <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  , _port <span class="ot">=</span> <span class="op">-</span><span class="dv">17</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  , _verifyToken <span class="ot">=</span> <span class="st">&quot;\SO\DLE9_1\NUL\210889\681130l\ENQ&quot;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  , _pageToken <span class="ot">=</span> <span class="st">&quot;q\r;h1\959827\&amp;1~\703396P1~\837562\190001xjf&quot;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  , _user <span class="ot">=</span> <span class="st">&quot;\466790\&amp;6\DC4j&quot;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  , _password <span class="ot">=</span> <span class="st">&quot;{H&quot;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  , _activeUsersContainer <span class="ot">=</span> <span class="dt">Dn</span> <span class="st">&quot;&quot;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  , _projectGroupsContainer <span class="ot">=</span> <span class="dt">Dn</span> <span class="st">&quot;U\ACK\616135\570186v\672268\571313&quot;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  , _projectGroupsOrgunits <span class="ot">=</span> <span class="st">&quot;\615852L$\598568\ESC6\fc&quot;</span> <span class="op">:|</span> [<span class="st">&quot;[h\DC4N[3pzk\b\SUB6\133277\14775&quot;</span>]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Работает! Теперь полиморфная функция <code>forAll</code>, обладающая типом <code>forAll :: (Show a, Testable prop) =&gt; Gen a -&gt; (a -&gt; prop) -&gt; Property</code> может принимать на вход “генератор конфигов” и проверять <code>Property</code> (по сути, чуть-чуть более хитрый предикат, где вместо <code>==</code> используется <code>===</code>).</p>
<pre class="console"><code>Env
  environment reading
    reads config from complete environment
      +++ OK, passed 100 tests.
    fails to read a config from incomplete environment
      +++ OK, passed 100 tests.</code></pre>
<p>Строка <code>+++ OK, passed 100 tests.</code> говорит о том, что было сгенерировано 100 случайных <code>Config</code>-ов для проверки инварианта – конвертации “окружение” и обратно. Количество тестов всегда можно задать аргументом командной строки при запусте тестов.</p>
<pre class="console"><code>$ stack test --test-arguments --qc-max-success=10000

Env
  environment reading
    reads config from complete environment
      +++ OK, passed 10000 tests.
    fails to read a config from incomplete environment
      +++ OK, passed 10000 tests.

Finished in 2.2859 seconds
2 examples, 0 failures</code></pre>
<p>От каких “ошибок” защищают такие defensive (regression, golden) тесты? Например, если случайно переставить местами строки при построении конфига – тесты это отловят. Либо если попытаться захардкодить какое-нибудь одно значение на этапе построения конфига – тесты тоже просигнализируют с несовпадении значений (сгенерированное случайное значение будет отличаться от статического хардкода). Изменение названия переменных, из которых читаем конфиг, такой тест тоже “отловит”, но отловит тут в кавычках, потому что такое падение теста не говорит о некорректности или неработоспособности программы, оно говорит лишь о том, что тесты нужно обновить, по сути “зашив” в процедуру генерации фейкового оружения новые названия переменных. В.С. непременно бы заметил еще на этапе написания тестов, что названия переменных повторяются и в реализации и в тестах – “не DRY”, сказал бы он в code review комментарии…</p>
<h2 id="суши-с-лупой">Суши с лупой</h2>
<p>Для того, чтобы избавиться из повторений, будем использовать популярную в функциональном программировании вещь – линзы. Линза, если совсем просто ее представить, это такая сущность, которая совмещает в себе getter и setter. Ну как setter… программирование же функциональное, immutability везде, нет никаких setter-ов, есть только функции <code>Value -&gt; Object -&gt; Object</code>, которые не меняют <code>Object</code>, а возвращают новый.</p>
<p>В структуре данных <code>Config</code> не случайно свойства начинались с символа подчеркивания, этому есть причина: для каждого поля структуры, <code>Haskell</code> объявит одноименную функцию с сигнатурой, например <code>_ldapHost :: Config -&gt; Text</code>. Если бы поле называлось <code>ldapHost</code>, то часто бы возникал конфликт имен при объявлении временных “переменных”. Да и смотря на использование <code>ldapHost</code> в коде подсознательно думаешь о нем, как о значении, а не как о функции.</p>
<p>Эту конвенцию “эксплуатирует” библиотека <code>lens</code>, позволяющая одной строкой сгенерировать линзы для каждого из полей структуры.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Config</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">ldapHost ::</span> <span class="dt">Lens'</span> <span class="dt">Config</span> <span class="dt">Text</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">ldapPort ::</span> <span class="dt">Lens'</span> <span class="dt">Config</span> <span class="dt">PortNumber</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Для чего вообще эти линзы удобны? Для работы со вложенным структурами данных в функциональном стиле. Имея список составных объектов.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Color</span> {<span class="ot">_shade ::</span> <span class="dt">Text</span>}</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Material</span> <span class="ot">=</span> <span class="dt">Material</span> {<span class="ot">_kind ::</span> <span class="dt">Text</span>,<span class="ot"> _color ::</span> <span class="dt">Color</span>}</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Player</span> <span class="ot">=</span> <span class="dt">Player</span> {<span class="ot">_name ::</span> <span class="dt">Text</span>,<span class="ot"> _material ::</span> <span class="dt">Material</span>}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Color</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Material</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>makeLenses '<span class="dt">'Player</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> players <span class="ot">=</span> [<span class="dt">Player</span> <span class="st">&quot;Bender&quot;</span> (<span class="dt">Material</span> <span class="st">&quot;metal&quot;</span> (<span class="dt">Color</span> <span class="st">&quot;shiny&quot;</span>))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>              ,<span class="dt">Player</span> <span class="st">&quot;Fry&quot;</span> (<span class="dt">Material</span> <span class="st">&quot;meat&quot;</span> (<span class="dt">Color</span> <span class="st">&quot;yellow&quot;</span>))</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>              ,<span class="dt">Player</span> <span class="st">&quot;Leela&quot;</span> (<span class="dt">Material</span> <span class="st">&quot;meat&quot;</span> (<span class="dt">Color</span> <span class="st">&quot;purple&quot;</span>))]</span></code></pre></div>
<p>Можно выполнять нетривиальные операции “вглубь” на immutable данных используя “композицию линз” через знакомый оператор <code>.</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>view material<span class="op">.</span>color<span class="op">.</span>shade <span class="op">$</span> <span class="fu">head</span> players</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;shiny&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (view <span class="op">$</span> material<span class="op">.</span>color<span class="op">.</span>shade) players</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;shiny&quot;</span>,<span class="st">&quot;yellow&quot;</span>,<span class="st">&quot;purple&quot;</span>]</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (over (material<span class="op">.</span>color<span class="op">.</span>shade) (append <span class="st">&quot;super_&quot;</span>)) players</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Player</span> {_name <span class="ot">=</span> <span class="st">&quot;Bender&quot;</span>, _material <span class="ot">=</span> <span class="dt">Material</span> {_kind <span class="ot">=</span> <span class="st">&quot;metal&quot;</span>, _color <span class="ot">=</span> <span class="dt">Color</span> {_shade <span class="ot">=</span> <span class="st">&quot;super_shiny&quot;</span>}}}</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>,<span class="dt">Player</span> {_name <span class="ot">=</span> <span class="st">&quot;Fry&quot;</span>, _material <span class="ot">=</span> <span class="dt">Material</span> {_kind <span class="ot">=</span> <span class="st">&quot;meat&quot;</span>, _color <span class="ot">=</span> <span class="dt">Color</span> {_shade <span class="ot">=</span> <span class="st">&quot;super_yellow&quot;</span>}}}</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>,<span class="dt">Player</span> {_name <span class="ot">=</span> <span class="st">&quot;Leela&quot;</span>, _material <span class="ot">=</span> <span class="dt">Material</span> {_kind <span class="ot">=</span> <span class="st">&quot;meat&quot;</span>, _color <span class="ot">=</span> <span class="dt">Color</span> {_shade <span class="ot">=</span> <span class="st">&quot;super_purple&quot;</span>}}}]</span></code></pre></div>
<p>Последний пример особенно нагляден, если бы не линзы, пришлось бы писать что-то вроде:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (\player <span class="ot">-&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> material <span class="ot">=</span> _material player</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        color <span class="ot">=</span> _color material</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        shade <span class="ot">=</span> _shade color</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> player { _material <span class="ot">=</span> material { _color <span class="ot">=</span> color { _shade <span class="ot">=</span> append <span class="st">&quot;super_&quot;</span> shade } } }</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  ) players</span></code></pre></div>
<p>Вернемся к нашей задачу из избавлению от дублирования. Объявим список пар ключ-линза – никто не запрещает так сделать, ведь линза, по сути, всего-лишь сложная функция, а функции в <code>Haskell</code> first-class значения:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>settings <span class="ot">=</span> [</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_LDAP_HOST&quot;</span>,        ldapHost),</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_LDAP_PORT&quot;</span>,        ldapPort <span class="op">.</span> isoRead <span class="op">.</span> packed),</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_PORT&quot;</span>,             port <span class="op">.</span> isoRead <span class="op">.</span> packed),</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_VERIFY_TOKEN&quot;</span>,     verifyToken),</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_PAGE_TOKEN&quot;</span>,       pageToken),</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_USERNAME&quot;</span>,         user),</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_PASSWORD&quot;</span>,         password),</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_USERS_CONTAINER&quot;</span>,  activeUsersContainer <span class="op">.</span> isoDn),</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_GROUPS_CONTAINER&quot;</span>, projectGroupsContainer <span class="op">.</span> isoDn),</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  (<span class="st">&quot;LDABOT_GROUPS_ORGUNITS&quot;</span>,  projectGroupsOrgunits <span class="op">.</span> isoNonEmpty <span class="op">.</span> splitted)]</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    isoRead ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Iso'</span> a <span class="dt">String</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    isoRead     <span class="ot">=</span> iso <span class="fu">show</span> <span class="fu">read</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    isoDn       <span class="ot">=</span> iso (\(<span class="dt">Dn</span> dn) <span class="ot">-&gt;</span> dn) <span class="dt">Dn</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    isoNonEmpty <span class="ot">=</span> iso toList fromList</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    splitted    <span class="ot">=</span> iso (intercalate <span class="st">&quot;,&quot;</span>) (splitOn <span class="st">&quot;,&quot;</span>)</span></code></pre></div>
<p>Обратите внимание на уже знакомые нам изоморфизмы снизу – пары функций, которые необходимы для преобразования линз к одному виду <code>Lens' Config Text</code>. Ведь исходя из типа <code>Config</code> линза <code>activeUsersContainer</code> работает с типом <code>Dn</code>, а мы хотим унифицировать все лизны в <code>settings</code> приведя их к одной, строковой сигнатуре.</p>
<p>Процедуру “чтения конфигурации” поменяем на свертку</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readConfig ::</span> (<span class="dt">Member</span> <span class="dt">Environment</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">Text</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">Config</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>readConfig <span class="ot">=</span> foldM reducer (<span class="dt">Config</span> {}) settings</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    reducer config (name, lens) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      value <span class="ot">&lt;-</span> <span class="fu">lookup</span> name</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> set lens value config</span></code></pre></div>
<p>Код осуществляет свертку <code>foldM</code> при помощи функции <code>reducer</code> списка <code>settings</code>, используя в качестве начального значения пустой <code>Config {}</code>. Функция <code>reducer</code> имеет на входе два параметра – <code>config</code> в качестве аккумулятор-а и пара ключ-линза из списка <code>settings</code>. Она читает (<code>lookup name</code>) значение переменной окружения, устанавливает прочитанное значение при помощи линзы в <code>config</code> и возвращает его. Таким образом, последовательно пройдясь по всему списку <code>settings</code> все поля структуры <code>Config</code> окажутся заполнены значениями.</p>
<p>Наконец-то мы можем избавиться от дублирования названий переменных в тестах. Вместо свертки, делаем простой обход списка <code>map</code> просматривая через линзу значения в <code>config</code>-е.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toEnvironmentMock ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">EnvironmentMock</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>toEnvironmentMock config <span class="ot">=</span> <span class="fu">map</span> (\(name, lens) <span class="ot">-&gt;</span> (name, view lens config)) settings</span></code></pre></div>
<p>Использование инверсии, идемпотентности и других инвариантов - здорово помогает при написании тестов, Вариативность, как говорит мой знакомый - при этом “на высоте” ;)</p>
  </section>
</article>

  </main>

  <footer>
    <a type="application/rss+xml" href="../../rss.xml">RSS Feed</a>
    Site generated by
    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </footer>
</body>

</html>